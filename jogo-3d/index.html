<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Velocity 3D - Wall Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        .ui { position: absolute; top: 0; left: 0; width: 100%; padding: 20px; display: flex; justify-content: space-between; box-sizing: border-box; z-index: 10; color: #0ff; pointer-events: none; }
        .btn-back { pointer-events: auto; background: #ff0000; color: white; text-decoration: none; padding: 10px 20px; border-radius: 5px; font-weight: bold; }
        #game-over { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 40px; border: 2px solid #ff0000; text-align: center; color: white; z-index: 100; border-radius: 10px; }
        button { background: #ff0000; color: white; border: none; padding: 10px 20px; cursor: pointer; border-radius: 5px; font-weight: bold; margin-top: 15px; }
    </style>
</head>
<body>

    <div class="ui">
        <a href="../index.html" class="btn-back">⬅ VOLTAR</a>
        <div style="font-size: 24px; font-weight: bold;">PONTOS: <span id="score">0</span></div>
    </div>

    <div id="game-over">
        <h1>BATEU NA PAREDE!</h1>
        <p>Pontos: <span id="final-score">0</span></p>
        <button onclick="location.reload()">REINICIAR</button>
    </div>

    <script>
        const init = () => {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1));

            // 1. Player Reduzido (Tamanho 0.5)
            const playerGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const playerMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
            const player = new THREE.Mesh(playerGeo, playerMat);
            scene.add(player);

            // 2. Limites Laterais (Corredor)
            const railGeo = new THREE.BoxGeometry(0.1, 0.5, 100);
            const railMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const leftRail = new THREE.Mesh(railGeo, railMat);
            leftRail.position.set(-3.5, -0.75, -40);
            scene.add(leftRail);
            const rightRail = leftRail.clone();
            rightRail.position.x = 3.5;
            scene.add(rightRail);

            const grid = new THREE.GridHelper(200, 40, 0xff00ff, 0x222222);
            grid.position.y = -0.3;
            scene.add(grid);

            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, 0);

            // Variáveis de Física e Jogo
            let score = 0, speed = 0.3, isGameOver = false;
            let velocityY = 0, isJumping = false;
            const gravity = -0.015;
            const walls = [];
            const particles = [];

            // 3. Mecânica de Paredes com Buracos
            function createWall() {
                if(isGameOver) return;
                const wallGroup = new THREE.Group();
                const holePos = Math.floor(Math.random() * 3) - 1; // -1 (esquerda), 0 (meio), 1 (direita)
                
                // Criamos 3 partes da parede, deixando uma vazia conforme o holePos
                for(let i = -1; i <= 1; i++) {
                    if(i === holePos) continue; // Pula a criação onde será o buraco
                    
                    const part = new THREE.Mesh(
                        new THREE.BoxGeometry(2.3, 4, 0.5),
                        new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 })
                    );
                    part.position.x = i * 2.3;
                    part.position.y = 1.5;
                    wallGroup.add(part);
                }
                
                wallGroup.position.z = -50;
                wallGroup.holeX = holePos * 2.3; // Guarda a posição do buraco para conferir pontos
                scene.add(wallGroup);
                walls.push(wallGroup);
            }
            setInterval(createWall, 2000);

            // Controles
            let moveLeft = false, moveRight = false;
            window.addEventListener('keydown', e => {
                if(e.key === "ArrowLeft") moveLeft = true;
                if(e.key === "ArrowRight") moveRight = true;
                if((e.key === "ArrowUp" || e.code === "Space") && !isJumping) {
                    velocityY = 0.3;
                    isJumping = true;
                }
            });
            window.addEventListener('keyup', e => {
                if(e.key === "ArrowLeft") moveLeft = false;
                if(e.key === "ArrowRight") moveRight = false;
            });

            function update() {
                if(isGameOver) return;
                requestAnimationFrame(update);

                // Movimento Horizontal
                if (moveLeft && player.position.x > -3) player.position.x -= 0.15;
                if (moveRight && player.position.x < 3) player.position.x += 0.15;

                // Física do Pulo
                player.position.y += velocityY;
                if (isJumping) {
                    velocityY += gravity;
                    if (player.position.y <= 0) {
                        player.position.y = 0;
                        isJumping = false;
                        velocityY = 0;
                    }
                }

                // Rastro de Fumaça
                if(Math.random() > 0.4) {
                    const smoke = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.5 }));
                    smoke.position.set(player.position.x, player.position.y, player.position.z + 0.3);
                    scene.add(smoke);
                    particles.push(smoke);
                }

                for(let i = particles.length-1; i>=0; i--) {
                    particles[i].position.z += speed;
                    particles[i].scale.multiplyScalar(0.95);
                    if(particles[i].scale.x < 0.05) { scene.remove(particles[i]); particles.splice(i,1); }
                }

                grid.position.z += speed;
                if(grid.position.z > 5) grid.position.z = 0;

                // Lógica das Paredes
                for(let i = walls.length - 1; i >= 0; i--) {
                    const w = walls[i];
                    w.position.z += speed;

                    // Detecção de Colisão complexa (se não estiver no buraco)
                    if(Math.abs(w.position.z - player.position.z) < 0.5) {
                        const inHole = Math.abs(player.position.x - w.holeX) < 0.8;
                        if (!inHole) {
                            isGameOver = true;
                            document.getElementById('final-score').innerText = score;
                            document.getElementById('game-over').style.display = 'block';
                        }
                    }

                    if(w.position.z > 5) {
                        scene.remove(w);
                        walls.splice(i, 1);
                        score += 50;
                        document.getElementById('score').innerText = score;
                        speed += 0.005;
                    }
                }
                renderer.render(scene, camera);
            }
            update();
        };

        if (window.THREE) init();
        else setTimeout(() => location.reload(), 1000);
    </script>
</body>
</html>
